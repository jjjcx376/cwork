#include "book_management.h"
#include "util.h"
#include <stdlib.h>
#include <string.h>

BookArray book_stock;

//initialize a bookArray
int init_book_array(BookArray *book_arr)
{
    book_arr->length = 0;
    book_arr->capacity = 16;
    book_arr->array = (Book*)malloc(sizeof(Book) * book_arr->capacity);
    if (book_arr->array == NULL)
    {
        return -1;
    }
    return 0;
}

//initialize the book database
void init_database()
{
    FILE* fp;
    init_book_array(&book_stock);
    fp = fopen("books.txt", "r");
    if (fp != NULL)
    {
        load_books(fp);
        fclose(fp);
    }
}

//saves the database of books in the specified file
//returns 0 if books were stored correctly, or an error code otherwise
int store_books(FILE *file)
{
    unsigned i;
    if (file == NULL) return -1;
    fprintf(file, "%u\n", book_stock.length);
    for (i = 0;i < book_stock.length; ++i)
    {
        fprintf(file, "%u %u %u\n", book_stock.array[i].id, book_stock.array[i].year, book_stock.array[i].copies);
        fprintf(file, "%s\n", book_stock.array[i].title);
        fprintf(file, "%s\n", book_stock.array[i].authors);
    }
    return 0;
}

//loads the database of books from the specified file
//the file must have been generated by a previous call to store_books()
//returns 0 if books were loaded correctly, or an error code otherwise
int load_books(FILE *file)
{
    unsigned int length;
    unsigned int i;
    int code;
    char *line, *p;
    Book book;
    if (file == NULL) return -1;
    line = get_file_input(file);
    length = atoi(line);
    for (i = 0;i < length; ++i)
    {
        line = get_file_input(file);
        p = strtok(line, " ");
        book.id = atoi(p);
        p = strtok(NULL, " ");
        book.year = atoi(p);
        p = strtok(NULL, " ");
        book.copies = atoi(p);

        line = get_file_input(file);
        book.title = strdup(line);
        line = get_file_input(file);
        book.authors = strdup(line);
        code = add_book(book);
        if (code != 0)
        {
            return code;
        }
    }
    return 0;
}

//extend Book array's capacity
static int extend_space(BookArray *book_arr)
{
    unsigned i;
    Book* new_space;
    unsigned new_capacity = book_arr->capacity * 2;
    if (new_capacity == 0)
    {
        new_capacity = 16;
    }
    new_space = (Book*)malloc(sizeof(Book) * new_capacity);
    if (new_space == NULL)
    {
        return -1;
    }
    for (i = 0;i < book_arr->length; ++i)
    {
        new_space[i] = book_arr->array[i];
    }
    if (book_arr->array != NULL)
    {
        free(book_arr->array);
    }
    book_arr->array = new_space;
    book_arr->capacity = new_capacity;
    return 0;
}

// adds a book to the ones available to the BookArray
int add_book_to_array(BookArray *book_arr, Book book)
{
    if (book_arr->length == book_arr->capacity)
    {
        if (-1 == extend_space(book_arr))
        {
            return -1;
        }
    }
    book_arr->array[book_arr->length] = book;
    ++book_arr->length;
    return 0;
}

//adds a book to the ones available to the library
//returns 0 if the book could be added, or an error code otherwise
int add_book(Book book)
{
    unsigned i;
    unsigned next_available_id = 0;
    for (i = 0;i < book_stock.length; ++i)
    {
        if (next_available_id < book_stock.array[i].id)
        {
            next_available_id = book_stock.array[i].id;
        }
    }
    book.id = next_available_id + 1;
    return add_book_to_array(&book_stock, book);
}

//removes a book from the library
//returns 0 if the book could be successfully removed, or an error code otherwise.
int remove_book(Book book)
{
    unsigned i;
    for (i = 0;i < book_stock.length; ++i)
    {
        if (book.id == book_stock.array[i].id)
        {
            break;
        }
    }
    if (i == book_stock.length)
    {
        return -1;
    }
    for (;i < book_stock.length - 1; ++i)
    {
        book_stock.array[i] = book_stock.array[i + 1];
    }
    --book_stock.length;
    return 0;
}

//finds books with a given title.
//returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the 
//provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
//array is the null pointer.
BookArray find_book_by_title (const char *title)
{
    unsigned i;
    BookArray books;
    init_book_array(&books);
    for (i = 0;i < book_stock.length; ++i)
    {
        if (strcmp(title, book_stock.array[i].title) == 0)
        {
            add_book_to_array(&books, book_stock.array[i]);
        }
    }
    return books;
}

//if the author is in authors
int find_author(const char *authors, const char* author)
{
    char line[1024];
    char* p;
    strcpy(line, authors);
    p = strtok(line, ",");
    while (p != NULL)
    {
        if (strcmp(p, author) == 0)
        {
            return 0;
        }
        p = strtok(NULL, ",");
    }
    return -1;
}

//finds books with the given authors.
//returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the 
//provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
//array is the null pointer.
BookArray find_book_by_author (const char *author)
{
    unsigned i;
    BookArray books;
    init_book_array(&books);
    for (i = 0;i < book_stock.length; ++i)
    {
        if (find_author(book_stock.array[i].authors, author) == 0)
        {
            add_book_to_array(&books, book_stock.array[i]);
        }
    }
    return books;
}

//finds books published in the given year.
//returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the 
//provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
//array is the null pointer.
BookArray find_book_by_year (unsigned int year)
{
    unsigned i;
    BookArray books;
    init_book_array(&books);
    for (i = 0;i < book_stock.length; ++i)
    {
        if (book_stock.array[i].year == year)
        {
            add_book_to_array(&books, book_stock.array[i]);
        }
    }
    return books;
}

//borrow a book from library
int borrow_book(unsigned id)
{
    unsigned i;
    for (i = 0;i < book_stock.length; ++i)
    {
        if (book_stock.array[i].id == id)
        {
            if (book_stock.array[i].copies != 0)
            {
                --book_stock.array[i].copies;
                return 0;
            }
            else
            {
                return 1;
            }
        }
    }
    return -1;
}

//return a book to library
int return_book(unsigned id)
{
    unsigned i;
    for (i = 0;i < book_stock.length; ++i)
    {
        if (book_stock.array[i].id == id)
        {
            ++book_stock.array[i].copies;
            return 0;
        }
    }
    return -1;
}

//find a book by id
Book* find_book_by_id(unsigned int id)
{
    unsigned i;
    for (i = 0;i < book_stock.length; ++i)
    {
        if (book_stock.array[i].id == id)
        {
            return &book_stock.array[i];
        }
    }
    return NULL;
}

//display someone book
void display_book(Book *book)
{
    printf("%-10u", book->id);
    printf("%-50s", book->title);
    printf("%-50s", book->authors);
    printf("%-8u", book->year);
    printf("%u\n", book->copies);
}

//display all books
void display_books(BookArray *book_arr)
{
    unsigned i;
    printf("%-10s%-50s%-50s%-8s%s\n", "ID", "Title", "Authors", "year", "copies");
    for (i = 0;i < book_arr->length; ++i)
    {
        display_book(&book_arr->array[i]);
    }
}
